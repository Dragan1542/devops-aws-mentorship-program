WIP Notes from (gdoc)[https://docs.google.com/document/d/1rZ53HY-yQzpRdlz_LKW06FybNgkbEPNa9-D822Y0ong/edit?usp=sharing]

terraform workspace select dev - used to select a workspace
Each terraform workspace uses its state file to manage the infrastructure associated with that particular workspace, at the start the backend has only one workspace, called “default” and only one of. state associated with that configuration
terraform workspace new stage - is the command used to create a new workspace, each workspace has its state file.\
terraform workspace show - can be used to output the current workspace
Workspace:
Has its state file, You can use a different variables file for this workspace if needed, changes to this workspace won’t impact other workspaces, it uses the same terraform code in the current directory
Remember that Terraform Cloud and Enterprise also have Workspaces, but they behave slightly differently. In Cloud and Ent, each workspace is still isolated from others, meaning it has its state. Still, often these workspaces point to different code repositories and use completely different Terraform configuration files.
index ( [“a”, “b”, “c”], “c”) - command that finds element index, a=0, b=1, c=2
backend - default is local, stores state as a local file on disk, terraform enterprise, s3, local, consul are supported
terraform import - used to import the existing resources under Terraform management. NOTE: Terraform DOES NOT generate configuration, it only modifies state. You’ll still need to write a configuration block(file) for the resource for which it will be mapped using the terraform import command.
Will bring imported resources under terraform management and add the new resource to the state file
resource address and resource ID must be provided 
You must update your terraform conf.  block for the imported resource before attempting to import the resource
terraform import command will not automatically update the referenced terraform resource block
terraform apply - using parallelism terraform provisions 10 resources by default.
The terraform apply command is used to apply the changes required to reach the desired state of the configuration, or the pre-determined set of actions generated by a terraform plan execution plan.
terraform apply -replace=<address>  manually marks a terraform-managed resource to be replaced, forcing it to be destroyed and recreated during the apply.
Terraform plan with the -out flag can be used to save the plan so it can be applied at a later time.
terraform plan -refresh-only or terraform apply -refresh-only allows drift to be detected,
join - produces a string by combining all elements of a given list of strings with the given delimiter. join(“-”, [“svr”, “prd”, “web”]_ = svr-prd-web
Terraform in General
Terraform supports GitHub, GitHub.com(OAuth), GitHub Enterprise, GitLab.com, GitLab EE and CE, Bitbucket Cloud, Bitbucket Server, Azure DevOps Server, Azure DevOps Services
Constraint expression to signify a version of a provider aws = “~> 1.2.0” will match any non-beta version of the provider between >= 1.2.0 and < 1.3.0, For example, 1.2.X
Multiple provider blocks can exist if a Terraform configuration is composed of multiple providers, which is a common situation.
If you want to deploy to multiple regions with the same configuration file you can use multiple provider blocks using an alias.
Provider block is not required, but it should be used to specify versions
Terraform provider is a plugin that Terraform uses to translate the API interactions with the service or provider
Each time a new provider can be used it must be declared or used in a configuration file and initialized (terraform init).
Starting in v0.12 terraform language now has built-in syntax for creating lists using the [ and ] delimiters, and replacing list() function.
Terraform is an immutable, declarative, Infrastructure as Code provisioning language based on Hashicorp Configuration Language, or optionally JSON.
Terraform resources dependency is handled:
Terraform analyzes any expressions within a resource block to find references to other objects and treats those references as implicit ordering requirements when creating, updating, or destroying resources.
Prefix +/- means that Terraform will destroy and recreate the resource, rather than update it in place. ~ means that resources will be updated in place.
Terraform is built on a plugin-based architecture. All providers and provisioners that are used in Terraform configuration are plugins.
HashiCorp style conventions suggest you that align the equals sign for consecutive arguments for easing readability for configurations
The format of resource block configurations are as follows:
<block type> "<resource type>" "<local name/label>"
If you introduce a new provider. Terraform needs to download the plugin to support the new resource that has been added, A terraform init will download the Infoblox plugin.
terraform init can now automatically download community providers starting with Terraform 0.13, and above.
terraform init downloads plugins into a subdirectory of the working directory, .terraform/providers, so each working directory is self-contained.
terraform init - downloads any referenced modules/plugins so they can be used locally.
To upgrade an existing provider that you have already downloaded, you need to run terraform init -upgrade
terraform version - is used to display the current version of Terraform
terraform init -migrate-state is used whenever a configuration’s backend changes, you must run terraform init again to validate and use reconfigure or migrate-state to update the backend configuraiton
Terraform is available for macOS, FreeBSD, OpenBSD, Linux, Solaris, and Windows. 
The Terraform language uses the following types for its values: string, number, bool, list (or tuple), and map (or object).
A Terraform Enterprise install that is provisioned on a network that does not have Internet access is generally known as an air-gapped install. These types of installs require you to pull updates, providers, etc. from external sources vs. being able to download them directly.
The easiest way for Terraform to read and write secrets from HashiCorp Vault is to use Vault provider
API and CLI access are managed with API tokens.
Special terraform configuration block type is used to configure terraform-specific settings and behaviors like requiring a minimum Terraform version to apply your configuration.
IaC makes changes idempotent, consistent, repeatable, and predictable.
A local value assigns a name to an expression, so you can use it multiple times within a module without repeating it.
A local path must begin with either ./ or ../ to indicate that a local path is intended, to distinguish from a module registry address.
When calling a child module, values can be passed to the module to be used within the module itself.
Remote backends are completely optional, if you don’t provide a backend configuration, Terraform will use the local default backend.
With remote backends if you want to store credentials you should define them outside of terraform.
When using collection types for variables you can use 2 ways:
Lists are defined like this: [“value1”, “value2”, “value3”] and 0=value1, 1=value 2 and 2=value 3 while u can use var.products[2] to call last
Maps are defined like this; { name=”John” age=52 } essentially they are using key/value type of structure
Terrafirn examples:
Functions: min, max, format, join, trim, length
Expressions: string, number, bool, null
Workspaces in OSS(open source) are often used within the same working directory while workspaces in Enterprise/Cloud are often (but not required) mapped to unique repos.
Single configuration file can use multiple providers
name = var.vpc_name, CIDR = var.vpc_cidr these are variables that are passed into the child module likely used for resource creation. They are declared elsewhere, likely in a variable.tf file and values are pulled from either the default value, a .tfvars file, environment variable, or from another resource.
.tfvars file can be used to set lots of variables, 
terraform console - command provides an interactive console for evaluating expressions
list - command is a comma-separated sequence of values in [], like [“a”, 15, true].
terraform.tfstate.d - A directory, where terraform stores the workspace states for the local state.
Module
To select a version number in a module configuration block in terraform tagged version v1.0.4? you use the command ?ref=v1.0.4
Single module can be called many times in a single configuration file.
TF_VAR_<name> - is used to set environment variables and it has to be in this format, For example, 
export TF_VAR_region=us-west-1
export TF_VAR_ami=ami-049d8641
export TF_VAR_list='[1,2,3]'
If you want to secure information you can use environment variable or credentials file.
TF_LOG - Can be set to one of the log levels TRACE, DEBUG, INFO, WARN, ERROR. Trace is the most lengthy (provides the most information, most detailed) and it is the default if TF_LOG is set to something other than a log-level name.
If you need to enable a persist logs to a specific file, you need to use two environment variables:
TF_LOG_PATH=”<file_path>”
TF_LOG=TRACE
Alias - is used when using the same provider with different configurations for different resources
terraform state - command is used for advanced state management. (modify the current state, such as removing items). To refresh Terraform state, use the command terraform apply -refresh-only. (does not modify your infrastructure but it does modify the state file if it detects changes were made outside of Terraform
Some of the features of terraform state file are:
Increased performances, determining the correct order to destroy resources, mapping configuration to real-world resources, meta-data, syncing
Terraform state show <resource address> will show you a lot of details on the resource, including things like the ID, IP address, the state of the resource, and lots more.
terraform state rm - command to remove resource (Cloud SQL instance or some other) from terraform state
If you use t it will not cause terraform to refresh its state.
terraform destroy - ALWAYS PROMPTS FOR CONFIRMATION
Terraform destroy is alias for “terraform apply -destroy”
Tostring -  is a type conversion function and not a string function, it converts its argument to a string value.
lookup({a="hello", b="goodbye"}, "c", "what?") - lookup retrieves the value of a single element from a map, given its key. If the given key does not exist, the given value is returned instead.
You can use terraform state mv when you wish to retain an existing remote object but track it as a different resource instance address in Terraform, such as if you have renamed a resource block or you have moved it into a different module in your configuration. In this case, Terraform would not touch the deployed resource, but would simply attach the existing object to the new address in Terraform.
Sentinel, and audit logging, SSO are paid features, while Public Module Registry and Workspaces are free features
Sentinel is an embedded policy-as-code framework integrated with HashiCorp Enterprise products. It enables fine-grained, logic-based policy decisions, and can be extended to use information from external sources.
Private Network Connectivity is available for Terraform Enterprise, Terraform Cloud for Business
Private Module Registry is available in every version except for Open-Source
Audi logging is available in Enterprise and Cloud for Business
Self-Managed Installation is available for Terraform Enterprise
Workspace can only be configured to a single VCS(Version Control System) repo, however, multiple workspaces can use the same repo, if needed.
Terraform OSS and Terraform Enterprise are versions of Terraform that can be installed locally on your servers, therefore giving you the ability to manage both the Terraform binary and the underlying operating system where Terraform runs.
Sentinel runs before a configuration is applied, therefore potentially reducing cost for public cloud resources
Modules also have output values, which are defined within the module with the output keyword. You can access them by referring to module.<MODULE NAME>.<OUTPUT NAME>. Like input variables, module outputs are listed under the outputs tab in the Terraform registry.
Output values are like the return values of a Terraform module and have several uses such as a child module using those outputs to expose a subset of its resource attributes to a parent module.
Child modules can only access variables that are passed in the calling module block.
Module that can has been called by another module is often referred to as child module
Count - is a reserved word since it’s used internally for Terraform to iterate over resource blocks and create multiple instances. The count parameter on resources can simplify configurations and let you scale resources by simply incrementing a number.
Terraform Public Module Registry 
The module must be on GitHub and must be a public repo.
Named terraform-<PROVIDER>-<NAME>. Must use a three-part name format, where <Name> reflects the type of infrastructure the module manages and <PROVIDER> is the main provider where it creates that infrastructure. The <NAME> segment can contain additional hyphens.
Repository description. The GitHub repository description is used to populate the short description of the module. This should be a simple one-sentence description of the module.
Standard module structure. The module must adhere to the standard module structure. This allows the registry to inspect your module and generate documentation, track resource usage, parse submodules and examples, and more.
x.y.z tags for releases. The registry uses tags to identify module versions. Release tag names must be a semantic version, which can optionally be prefixed with a v. For example, v1.0.4 and 0.9.2. To publish a module initially, at least one release tag must be present. Tags that don't look like version numbers are ignored.
<NAMESPACE>/<NAME>/<PROVIDER> = hashicorp/consul/AWS directory
Terraform Private Module Registry
You can use modules from a private registry, like the one provided by Terraform Cloud. Private registry modules have source strings of the form <HOSTNAME>/<NAMESPACE>/<NAME>/<PROVIDER>. This is the same format as the public registry, but with an added hostname prefix.
Both the terraform get and terraform init commands will install and update-modules. The terraform init command will also initialize backends and install plugins.
During terraform init - Initliazes the backend configuration, downloads the required modules referenced in the configuration, and downloads the providers/plugins required to execute the configuration.
Caches the source code locally for referenced modules, and downloads required providers sued in your configuration file. Prepares the working directory for use with tf.
Terraform caches these modules in the .terraform/modules subdirectory in the current working directory.
This is also true when you include multiple different modules in a new conf file, and run terrafomr init, terraform OSS download and stores this modules locally in .terraform/modules
providers/plugins are downloaded to .terraform/provides, and modules are downloaded to the .terraform/modules directory NOTE:providers are aws/azure/gcp…
Providers can be installed from
Terraform plugin cache, plugins directory, terraform registry, and official HashiCorp releases site.
Facts about providers: Some providers are maintained by HashiCorp, some providers are community-supported, they allow anybody to write a provider and publish it to the registry, and providers can be written and maintained by an outside organization such as AWS F5 or Microsoft.
Uses: abstracts the target platform’s API from the end-user, enables the deployment of resources to multiple platforms, such as public cloud, private cloud, or other SaaS, PaaS, or IaaS services, enables a plugin architecture that allows Terraform to be extensible without having to update Terraform core.
The terraform apply -replace=”aws_instance.database” command manually marks a Terraform-managed resource for replacement, forcing it to be destroyed and recreated on the apply execution.
You could also use terraform destroy -target <virtual machine> and destroy only the virtual machine and then run a terraform apply again.
terraform validate - validates configuration files in a directory, referring only to the configuration and not accessing any remote services such as remote state, provider APIs, etc. It is mainly used to check for eros within modules, attribute names, and value types to make sure they are syntactically valid.
Directory must be initialized before running (terraform init has to be used before you can use terraform validate)
terraform force-unlock - removes the lock on the state for the current configuration.
Local-backend - Stores state on the local filesystem, locks the state using system APIs and performs operations locally. OSS stores it’s state file in local backend
terraform show - is a command used to provide human-readable output from a state or plan file. This can be used to inspect a plan to ensure that the planned operations are expected, or to inspect the current state as Terraform sees it.
.gitignore file should be configured to ignore terraform.tfvars and terraform.tfstate
Remote-exec supports ssh and winrm connection types.
local-exec - Used to execute one or more commands on the machine running Terraform, and to invoke a local executable
Remote-exec provisioner >> it can be used to execute a script on the server once it has been provisioned
terraform fmt - command is used to rewrite Terraform configuration files to a canonical format and style.
If you want to scan/format sub-directories you can add the flag -recursive to instruct terraform fmt to also process files in subdirectories.
dynamic block - acts much like a for expression, but produces nested blocks instead of a complex typed value. It iterates over a given complex value and generated a nested block for each element of that complex value.
Note: Produces nested configuration blocks instead of a complex typed value
Data source -  allows data to be fetched or computed for use elsewhere in Terraform configuration. (Data defined outside of terraform)
terraform console - command provides an interactive command-line console for evaluating and experimenting with expressions.	echo 'split(",", "foo, bar, baz")' | terraform console
In order to use the terrafomr console command, the CLI must be able to lock state to prevent changes (true)
State locking - can be used with Kubernetes backend, consul backend, and s3 backend(dynamo DB)
Data block -  is used when a reference resource is NOT a part of your Terraform configuration, you need to query that resource using a data block.
Enhanced storage backend - allows you to execute your Terraform on infrastructure either locally or in Terraform Cloud.
terraform block - is a block used to terraformr-specific settings and behaviors for terraform





Terraform Bitbucket Pipeline:
https://gist.github.com/mbaitelman/ab5bb06847fb6e8756a22a47335aab78#file-terraform-tf-L8

Terraform Feature Matrix:
https://www.datocmsre-assets.com/2885/1602500234-terraform-full-feature-pricing-tablev2-1.pdf

